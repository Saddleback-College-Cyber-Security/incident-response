# Command Line Tools for *NIX

## Table of Contents

[**Incident Response Home**](../README.md)
- [Incident Overview](#Incident-Overview)
- [I Need Help, Where Can I Go?](#I-Need-Help,-Where-Can-I-Go?)
- [General Commands](#General-Commands)
- [I/O and Redirection](#I/O-and-Redirection)
	- [Redirection](#Redirection)
	- [Pipes](#Pipes)
	- [Filters](#Filters)
- [Installing And Managing Packages](#Installing-And-Managing-Packages)
	- [.deb Based (Debian Family)](#.deb-Based-(Debian-Family))
	- [.rpm Based (CentOS/RHEL, Fedora, SUSE)](#.rpm-Based-(CentOS/RHEL,-Fedora,-SUSE))
	- [Pacman Based (Arch Family)](#Pacman-Based-(Arch-Family))
- [Networking](#Networking)
	- [Tools](#Tools)
	- [Show Interfaces](#Show-Interfaces)
	- [Turn Interfaces on/off](#Turn-Interfaces-on/off)
	- [Set Address for Interface](#Set-Address-for-Interface)
	- [Promiscuous Mode](#Promiscuous-Mode)
	- [Routes](#Routes)
	- [DNS Stuff](#DNS-Stuff)
	- [ARP](#ARP)
	- [Sockets and Ports](#Sockets-and-Ports)
	- [Firewalls](#Firewalls)
	- [Other Useful Commands](#Other-Useful-Commands)
- [Connecting to Remote Hosts](#Connecting-to-Remote-Hosts)
	- [telnet](#telnet)
	- [ssh](#ssh)
- [System Identification](#System-Identification)
- [User Administration](#User-Administration)
	- [User Identification](#User-Identification)
	- [User Manipulation](#User-Manipulation)
	- [Removing Unauthorized Users](#Removing-Unauthorized-Users)
- [Service Administration](#Service-Administration)
	- [Systemd](#Systemd)
	- [Service Wrapper](#Service-Wrapper)
	- [Scheduling Tasks](#Scheduling-Tasks)
- [Things to Add](#Things-to-Add)

## Incident Overview

Navigation and use of command line tools is a viable skill for any cyber security analyst. This section details various scenarios and commands for different *NIX systems.

## I Need Help, Where Can I Go?

The manual `man` is where most of the important info will be for any given command. The arg passed to man is normally the name of a program, utility or function.

```shell
$ man <ARG>
$ man man #This will show how to use the man command
```

## General Commands

Superuser do `sudo` is a way to run a command (and only that command) as root while logged in as a non-root user that has sudo privileges.

>Note: asks for root password. (also "caches" user's credentials for future commands)

```shell
$ sudo <COMMAND> #Run COMMAND as root from a non-root user account 
$ sudo !! #Run the previous command as root
$ sudo -k #Invalidates user's cached credentials
```

The switch user `su` command is used to become another user during a login session.

```shell
$ su #Become root
$ su <USER> #Become USER
```

`exit` is used for normal process termination including exiting login sessions (including ssh) and scripts.

```shell
$ exit #exit
$ exit <NUM> #exit with code NUM
```

The List command `ls` is used to show the files in the current directory.

```shell
$ ls #Print files in current directory
$ ls <DIR> #Print files in DIR
```

`cd` is used to change directory.

```shell
$ cd <DIR> #Change directory to DIR
```

The concatenate `cat` command can be used to print files to the standard output.

```shell
$ cat <FILE> #Prints FILE to screen
```

## I/O and Redirection

Command redirection is the basis that many scripts and programs are based on. It is what allows for the manipulation of data in various forms, including being able to write to files vs the screen.

Input and output on linux systems are handled by "streams":
- **standard input** (stdin) (0)
	- carries data from a user (or file) to programs
- **standard output** (stdout) (1)
	- writes the data that the program produces (when not redirected, to the terminal)
- **standard error** (stderr) (2)
	- writes errors generated by the program (also writes to terminal when not redirected)

### Redirection

Stream redirection can overwrite or append to the destination. (exclusively for file manipulation)

**Overwrite**
- < - stdin
- \> - stdout
- 2> - stderr

**Append**
- << - stdin
- \>> - stdout
- 2>> - stderr

```shell
$ cat > file2.txt < file1.txt #Writes the data in file1.txt to file2.txt
$ cat file1.txt > file2.txt #Writes the data in file1.txt to file2.txt
$ #Because of the way the cat command works, both of these produce the same result

$ echo "hello" >> file1.txt #Writes 'hello' to the end of file1.txt
```

### Pipes

Pipes are used to redirect a stream from one program to another. Pipes in linux are represented by a vertical bar: \*`|`*

### Filters

Filters are commands that alter piped redirection and output.
> Note that filter commands are also standard Linux commands that can be used without pipes.

Just about any command can be used as a filter or be the recipient of data from a piped command. Here are some examples:
- `grep` - matches strings
- `tr' - find and replace tool

```shell
$ echo "Hi, thanks for being here today" | tr ',' '!'
Hi! thanks for being here today
$ ls -la | grep myfile.txt
-rw-r--r--   1 tom tom   16295 Mar 30 12:15 myfile.txt
```

## Installing And Managing Packages

Package management is different for every [disrto and its derivatives](https://en.wikipedia.org/wiki/List_of_Linux_distributions). Usually distros are classified by the type of packages they use (`.deb`, `.rpm`, `.pkg.tar.zst`, etc.)

>**Commands that manipulate system settings or files typically require root privileges. See [`sudo`](#General-Commands)**

### .deb Based (Debian Family)

Debian and its derivatives use the [dpkg](https://wiki.debian.org/Teams/Dpkg) package manager as well as its frontends such as [apt](https://wiki.debian.org/Apt), `apt-get`, and [aptitude](https://wiki.debian.org/Aptitude).

```shell
$ dpkg -i <PACKAGEFILE> #Install PACKAGEFILE (PACKAGEFILE must be in current dir)
$ dpkg -r <PACKAGENAME> #Remove PACKAGENAME

$ apt install <PACKAGENAME> #Install PACKAGENAME
$ apt remove <PACKAGENAME> #Remove PACKAGENAME
$ apt update #Update local repository
$ apt upgrade #Upgrade packages

$ apt-get install <PACKAGENAME> #Install PACKAGENAME
$ apt-get remove <PACKAGENAME> #Remove PACKAGENAME
$ apt-get purge <PACKAGENAME> #Remove PACKAGENAME and delete config files
$ apt-get update #Update local repository
$ apt-get upgrade #Upgrade packages
```

### .rpm Based (CentOS/RHEL, Fedora, SUSE)

RPM based distributions use the [rpm](https://rpm.org/documentation.html) package manager. Most rpm based distros use frontends such as [yum](http://yum.baseurl.org/), [DNF](https://rpm-software-management.github.io/), and `up2date`.

```shell
$ rpm -i <PACKAGEFILE> #Install PACKAGEFILE (PACKAGEFILE must be in current dir)
$ rpm -e <PACKAGENAME> #Remove PACKAGENAME
$ rmp -U <PACKAGENAME> #Update PACKAGENAME

$ yum install <PACKAGENAME> #Install PACKAGENAME
$ yum remove <PACKAGENAME> #Remove PACKAGENAME
$ yum check-update #Update local repository
$ yum update #Upgrade packages

$ dnf install <PACKAGENAME> #Install PACKAGENAME
$ dnf remove <PACKAGENAME> #Remove PACKAGENAME
$ dnf check-update #Update local repository
$ dnf update #Upgrade packages

$ up2date -i <PACKAGENAME> #Install PACKAGENAME
$ up2date -u #Upgrade packages
```

### Pacman Based (Arch Family)

Distros in the Arch Linux family use the [pacman](https://wiki.archlinux.org/index.php/Pacman) package manager.

```shell
$ pacman -S <PACKAGENAME> #Install PACKAGENAME
$ pacman -R <PACKAGENAME> #Remove PACKAGENAME
$ pacman -Syu #Upgrade packages
```

## Networking

Networking on *nix based machines is complicated because of how many tools there are and what comes pre-installed on each distro. These are some of the basic tools and how to use them.

>**Commands that manipulate system settings or files typically require root privileges. See [`sudo`](#General-Commands)**

### Tools

The most popular tools are:

```shell
$ dig #DNS lookup utility
$ host #DNS lookup utility
$ nslookup #DNS lookup utility

$ ethtool #Query or control network driver and hardware settings
$ ifconfig #General purpose network interface manipulator (deprecated and replaced by ip)
$ ip #General purpose network interface manipulator (most options can be shortened e.g. address to addr)
$ iw #General purpose wireless network interface manipulator
$ iwconfig #General purpose wireless network interface manipulator (deprecated and replaced by iw)
$ nmcli & NetworkManager #Network management daemon

$ nameif #Name interfaces based on MAC addresses

$ arp #Manipulate or display the system ARP cache
$ netstat #Show network info

$ traceroute #Print the route packets take to destination
$ ping #Send ICMP ECHO_REQUEST to network hosts
$ route #Show/manipulate the IP routing table

$ ss #Show socket information
```

### Show Interfaces

```shell
$ ifconfig #Show enabled interfaces' info
$ ifconfig -a #Show all interfaces' info
$ ifconfig <INTERFACE> #Show INTERFACE's info

$ ip address #Show all interfaces' info
$ ip address show <INTERFACE> #Show INTERFACE's info

$ ethtool <INTERFACE> #Show INTERFACE's info

$ nmcli dev show #Show all interfaces' info
$ nmcli dev show <INTERFACE> #Show INTERFACE's info

$ netstat -i #Show all interfaces' info
```

### Turn Interfaces on/off

```shell
$ ifconfig <INTERFACE> up #Turn INTERFACE on
$ ifconfig <INTERFACE> down #Turn INTERFACE off
$ ifup <INTERFACE> #Turn INTERFACE on
$ ifdown <INTERFACE> #Turn INTERFACE off
$ ip link set <INTERFACE> down #Turn INTERFACE off
$ ip link set <INTERFACE> up #Turn INTERFACE on
$ nmcli con up <INTERFACENAME> #Turn INTERFACENAME on
$ nmcli con down <INTERFACENAME> #Turn INTERFACENAME off
```

### Set Address for Interface

#### Temporary (resets after reboot):
```shell
$ ifconfig <INTERFACE> <IPADDRESS> netmask <MASK> #Set INTERFACE to IPADDRESS with netmask MASK
$ route add default gw <GATEWAY> <INTERFACE> #Set the default GATEWAY on INTERFACE
$ service network restart
```
OR
```shell
$ ip address add <IPADDRESS> dev <INTERFACE> #Set INTERFACE to IPADDRESS in CIDR format
$ ip route add <GATEWAY> dev <INTERFACE> #Set the GATEWAY on INTERFACE in CIDR format
$ systemctl restart network
```
OR
```shell
$ nmcli device modify <INTERFACENAME> ipv4.address <IPADDRESS> gw4 <GATEWAY> #Set INTERFACENAME to IPADDRESS in CIDR format with GATEWAY
```

#### Permanent:

RHEL / CentOS / Fedora:

```shell
Edit:
$ /etc/sysconfig/network
$ /etc/sysconfig/network-scripts/ifcfg-<INTERFACE>
$ /etc/resolv.conf
Then Run:
$ systemctl restart network
```

Debian/ Ubuntu:

```shell
Edit:
$ /etc/network/interfaces
$ /etc/resolv.conf
Then Run:
$ systemctl restart network
```

### Promiscuous Mode

```shell
$ ifconfig <INTERFACE> promisc #Turn promiscuous mode on
$ ip link set <INTERFACE> promisc on #Turn promiscuous mode on
$ ifconfig <INTERFACE> -promisc #Turn promiscuous mode off
$ ip link set <INTERFACE> promisc off #Turn promiscuous mode off
```

### Routes

```shell
$ route -n #Show default routes (in numeric values)
$ route add default gw <GATEWAY> <INTERFACE> #Set the default GATEWAY on INTERFACE in CIDR format
$ ip route show #Show default routes
$ ip route add <GATEWAY> dev <INTERFACE> #Set the GATEWAY on INTERFACE in CIDR format
$ ip route del <GATEWAY> dev <INTERFACE> #Delete the GATEWAY on INTERFACE in CIDR format
$ netstat -r #Show default routes
```

### DNS Stuff

```shell
$ dig <HOSTNAME> #Request HOSTNAME resolution from nameserver
$ host <HOSTNAME> #Request HOSTNAME resolution from nameserver
$ nslookup <HOSTNAME> #Request HOSTNAME resolution from nameserver
$ nslookup <IPADDRESS> #Request HOSTNAME from nameserver based on IPADDRESS
```

### ARP
```shell
$ arp -n #Show all cached values in ARP table (in numeric values)
$ arp -s <IPADDRESS> -i <INTERFACE> <MAC> #Add entry to ARP table
$ arp -d <IPADDRESS> #Delete entry from table

$ ip neighbor show
$ ip neineighborgh add <IPADDRESS> lladdr <MAC> dev <INTERFACE> nud <STATE> #Add entry to ARP table. State: [permanent|noarp|stale|reachable]
$ ip neighbor del <IPADDRESS> dev <INTERFACE> #Delete entry from table
$ ip -s -s neighbor flush <IPADDRESS> #Flush entry from table
```

### Sockets and Ports

```shell
$ netstat -a #All ports (options can be combined e.g. netstat -at)
$ netstat -t #TCP ports
$ netstat -u #UDP ports
$ netstat -l #Listening ports
$ netstat -s #Statistics
$ ss (same options as netstat)
```

### Firewalls

There are many different options for firewalls in linux. Because of this, only `iptables` and `ufw` will be covered.

```shell
$ iptables -S #List rules
$ iptables -A INPUT -s <IPADDRESS> -j ACCEPT #Allow IP Address
$ iptables -I INPUT -s <IPADDRESS> -j DROP #Block IP Address
$ iptables -A INPUT -p tcp --dport <PORT> -j ACCEPT #Allow PORT
$ iptables -A INPUT -p tcp --dport <PORT> -j DROP #Block PORT
$ iptables -D <RULE> #Delete previously added RULE
$ iptables -D INPUT -p tcp --dport 80 -j DROP

$ ufw status #List rules
$ ufw allow from <IPADDRESS> to any #Allow IP Address
$ ufw deny from <IPADDRESS> to any #Block IP Address
$ ufw allow <PORT> #Allow PORT
$ ufw block <PORT> #Block PORT
$ ufw delete <RULE> #Delete previously added RULE
$ ufw delete block 80
```

### Other Useful Commands

```shell
$ traceroute <HOSTNAME/IPADDRESS> #Show route to HOSTNAME or IPADDRESS (-n for numerical)
$ ping <HOSTNAME/IPADDRESS> 
```

## Connecting to Remote Hosts

### telnet

The TELNET protocol provides plain text interaction between machines using a virtual terminal connection. Because `telnet` is plain text, it is recommended to use `ssh`, which is encrypted.

```shell
$ telnet <ADDRESS> #Connect to ADDRESS (asks for username)
$ telnet <ADDRESS> <PORT> #Connect to ADDRESS on PORT
$ telnet -l <USER> <ADDRESS> #Connect to ADDRESS as USER
```

### ssh

The secure shell client `ssh` is a program that allows the connection to a remote machine that is running an ssh server.

```shell
$ ssh <USER>@<ADDRESS> #Connect to ADDRESS as USER
$ ssh <USER>@<ADDRESS> -p <PORT> #Connect to ADDRESS as USER on remote PORT
$ ssh <ADDRESS> #Connect to ADDRESS as your logged in username
```

`scp` is similar to [(s)ftp](../services/file_transfer_protocol.md) where they both tranfer files over the ssh protocol, however, they do have different use cases.

>note FILE requires the full path to the file. If HOST is omitted, FILE will be from the machine running the command

```shell
$ scp [[<USER>@]<HOST1>:]<FILE1> [[<USER>@]<HOST2>:]<FILE2> #Transfer FILE1 on HOST1 to HOST2 as FILE2
```

## System Identification

Identifying a fresh system you have been handed with no prior context is important for knowing which command syntax to use.

```shell
$ cat /etc/lsb-release #Print Distribution info
$ cat /etc/issue.net #Print Distribution info
$ cat /etc/debian_version  #Debian Only
```

The `uname` command shows system information.

```shell
$ uname #Print kernel name
$ uname -a #Print all system info: kernel, node, release, version, machine, processor, platform, os
```

The `hostname` command(s) can be used to show or change the name of the machine.

```shell
$ hostname #Show or set the hostname
$ domainname #Show or set the domain name
$ dnsdomainname #Show or set the dns domain name
```

## User Administration

### User Identification

```shell
$ cat /etc/passwd #Show pwd file for all users on the system
$                 #(pwds not actually stored here. They are in /etc/shadow)
$ getent passwd {1000..60000} #Show non-application users
```

Both `who` and `w` show info about currently logged in users.

```shell
$ who
$ who -u #Show non-application users that are logged in
```

The `lastlog` command shows info about when a user was last logged on.

```shell
$ lastlog #Show info for all users
$ lastlog -u <USER> #Show info for only USER
```

### User Manipulation

`passwd` is used for changing passwords for user accounts.

```shell
$ passwd #Change password for current user
$ passwd <USER> #Change password for USER
$ passwd -l <USER> #Lock user account
```

`useradd` and `groupadd` add users and groups to the system.

```shell
$ useradd <USER> #Add USER to the system
$ groupadd <GROUP> #Add GROUP to the system
```

`usermod` changes system account files

```shell
$ usermod -a -G <GROUP> <USER> #Add USER to GROUP
```

`userdel` deletes a user from the system

```shell
$ userdel <USER> #Delete USER from system
$ userdel -r <USER> #Delete USER from system and delete the user's $HOME
```

### Removing Unauthorized Users

Once an unauthorized user has been identified (see [User Identification](#User-Identification) for more info), they can be imediately kicked off the system by killing their shell's process.

```shell
$ w #Show all users logged into the system (TTY is the terminal interface)
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU  WHAT
steve    pts/0    10.0.0.16        05:20    0.00s  0.05s  0.01s w
tom      pts/2    216.58.193.206   05:23    1:05   0.04s  0.00s nmap

$ ps a | grep "pts/2" #Show process number of the user "tom"
31234 pts/0    Ss     0:00 -bash
31289 pts/0    S+     0:00 nmap

$ echo "Unauthorized access." | write tom pts/2 #Send user tom a message on terminal pts/2

$ kill -9 31234 #Force terminate the remote user's shell (use the lowest process number shown)
```

## Service Administration

### Systemd

Most modern linux systems use an "**init**" program called `systemd` to manage services and the system. The `systemctl` is the most used command in the suite.

```shell
$ systemctl list-units -t service --all #List all services installed on a machine
$ systemctl list-units -t service #List all active services
$ systemctl start <SERVICE>
$ systemctl stop <SERVICE>
$ systemctl restart <SERVICE> #Stop SERVICE and then start it
$ systemctl reload <SERVICE> #Reloads the configuration files without stopping SERVICE
$ systemctl enable <SERVICE> #Start SERVICE on system boot
$ systemctl disable <SERVICE> #Start SERVICE on system boot
$ systemctl status <SERVICE> #Show status information for SERVICE, followed by recent logs
$ systemctl -H <HOST> <COMMAND> <SERVICE> #Runs a systemctl COMMAND on HOST over ssh
```

`systemd` also implements the `halt`, `poweroff`, `reboot` commands:

```shell
$ halt #Tells hardware to stop CPU functions but leaves it powered on
$ poweroff #Send ACPI shutdown signal
$ reboot #Reboots system
```

### Service Wrapper

For machines that don't have `systemd`, try `service`. It is a wrapper script that allows basic control of services like start, stop, and status among others. `service` actually will look and use whatever "**init**" system is installed on the system. See [here](https://askubuntu.com/questions/903354/difference-between-systemctl-and-service-commands) for more info.

```shell
$ service --list-all #List all services installed on a machine
$ service <SERVICE> stop
$ service <SERVICE> start
$ service <SERVICE> restart #Stop SERVICE and then start it
$ service <SERVICE> status #Show status information for SERVICE, followed by recent logs
$ service <SERVICE> reload #Reloads the configuration files without stopping SERVICE
```

### Scheduling Tasks

Task Scheduling is an important part of any OS. Most Linux systems use a daemon called `cron` (named after the greek god chronos). `cron` runs commands specified in the user's crontab file.

```shell
$ crontab -l #Show the user's crontab
$ crontab -r #Remove the user's crontab
$ crontab -e #Edit the user's crontab
```

Running "`crontab -e`" for the first time will ask for the default editor to be used. It will then create a blank crontab file (usually in the /var/spool/cron/ directory). Tasks are entered at the end of the file in the format:

```shell
m h d m w command

m minute 0-59
h hour 0-23
d day 1-31
m month 1-12
w weekday 0-6

command can be launching an external script, program or just a command
```

see [here](https://www.howtogeek.com/101288/how-to-schedule-tasks-on-linux-an-introduction-to-crontab-files) for more info.

## Things to Add

installing apps
- add gentoo and slackware

>**[REQUEST]** More info needed on IP tables

>**[Note]** Remember to use markdown syntax to organize information in useful ways.
